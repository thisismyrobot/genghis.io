import controlqueue
import drivers
import json
import logging
import traceback
import webapp2
import api.qr

from google.appengine.api import channel
from google.appengine.api import memcache


def serialcommand(driverid, key, *args):
    """ Returns the serial command from the driver for the driverid, key and
        args.
    """
    func = drivers.drivers[driverid]['outputs'][key]['func']
    serialdata = func(*args)
    return serialdata


class Stop(webapp2.RequestHandler):
    """ Stops a bot.
    """
    def get(self, client_id, driverid):
        """ Replace the controls queue with a stop command for the driver.
        """
        controls_key = 'Controls-{}'.format(client_id)
        memcache.set(controls_key, [('stop', [], 0, '')])


class Ping(webapp2.RequestHandler):
    """ Receives bot-based pings, executes browser code and returns that.
    """
    @staticmethod
    def _serialdata(driverid, key, *args):
        """ Returns the appropriate serial data for the driver, None on
            failure.
        """

    def get(self, qrcode, driverid):
        """ Call this method and it will trigger the execution of the code in
            the browser, returning the most current control. As the process is
            asyncronous there is very little chance of the most recent control
            returned being the most recent from the browser's code exectution.

            The driverid and qrcode are passed in via the URL, the driveid is
            used to format the key-value pairs into serial data.
        """
        serialstring = ''
        cmdecho = ('',())

        try:
            # Get the client_id
            client_id = api.qr.get_client_id(qrcode)

            # Early check for this being an invalid client id
            if client_id is None:
                raise Exception(
                    'Submitted QR code does not have an associated Client ID')

            # Load the controls queue
            controls_key = 'Controls-{}'.format(client_id)
            stored_controls = memcache.get(controls_key)
            if stored_controls is None:
                stored_controls = []

            # Work out what behaviours are blacklisted - stops mad re-triggering
            blacklisted_behaviours = controlqueue.blacklisted_behaviours(stored_controls)

            # Tell the browser to execute the code, passing the blacklisted
            # behaviours TODO: this will have any new inputs passed via this
            # message too soon.
            data = {
                'type': 'execute',
                'blacklist': blacklisted_behaviours,
            }
            channel.send_message(client_id, json.dumps(data))

            # While we have valid controls
            while len(stored_controls) > 0:
                # Destructively grab the head of the queue, updating memecache
                # immediately.
                head = stored_controls[0]
                stored_controls = stored_controls[1:]
                memcache.set(controls_key, stored_controls)

                # If the head is a debug message, send it to the user
                if head[0] == '__debug__':
                    # Send to the user via Channel API
                    channel.send_message(client_id, json.dumps({
                        'type': 'debug',
                        'text': head[1],
                    }))

                    # Continue on to the next item
                    continue

                # Otherwise, we have a valid control so we send it to the driver
                # so we can return the result to the user.
                serialstring = serialcommand(driverid, head[0], *head[1])
                cmdecho = (head[0], head[1])
                break

        except:
            # Log the errors here, but still return a blank control. This
            # should stop people guessing QR codes through feedback.
            logging.error(traceback.format_exc())

        pingdata = {
            'control': serialstring,
            'cmdecho': cmdecho,
        }
        self.response.write(json.dumps(pingdata))


class Recorder(webapp2.RequestHandler):
    """ Records controls generated by executing code in the browser.
    """
    def post(self, client_id):
        """ POST a 'controls' JSON element here and the value(s) will be added
            to those stored under the client_id in memcache. 
        """
        try:
            json_payload = json.loads(self.request.body)

            # Parse out the controls, behaviour priorities and memory
            new_controls = json_payload['controls']
            behaviours = json_payload['behaviours']
        except:
            return

        # Load/create the Controls store from memcache
        controls_key = 'Controls-{}'.format(client_id)
        stored_controls = memcache.get(controls_key)
        if stored_controls is None:
            stored_controls = []

        try:
            # Record the new controls, the behaviours help with sorting
            stored_controls = controlqueue.update(stored_controls,
                                                  new_controls, behaviours)
        except:
            return

        # Store the updated controls
        memcache.set(controls_key, stored_controls)
